// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/demola234/defifundr/internal/core/domain"
	"github.com/demola234/defifundr/internal/core/ports"
	"github.com/google/uuid"
)

type FakeUserRepository struct {
	CheckEmailExistsStub        func(context.Context, string) (bool, error)
	checkEmailExistsMutex       sync.RWMutex
	checkEmailExistsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	checkEmailExistsReturns struct {
		result1 bool
		result2 error
	}
	checkEmailExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CreateUserStub        func(context.Context, domain.User) (*domain.User, error)
	createUserMutex       sync.RWMutex
	createUserArgsForCall []struct {
		arg1 context.Context
		arg2 domain.User
	}
	createUserReturns struct {
		result1 *domain.User
		result2 error
	}
	createUserReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	DeactivateUserStub        func(context.Context, uuid.UUID) error
	deactivateUserMutex       sync.RWMutex
	deactivateUserArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	deactivateUserReturns struct {
		result1 error
	}
	deactivateUserReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteUserStub        func(context.Context, uuid.UUID) error
	deleteUserMutex       sync.RWMutex
	deleteUserArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	deleteUserReturns struct {
		result1 error
	}
	deleteUserReturnsOnCall map[int]struct {
		result1 error
	}
	GetMFASecretStub        func(context.Context, uuid.UUID) (string, error)
	getMFASecretMutex       sync.RWMutex
	getMFASecretArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	getMFASecretReturns struct {
		result1 string
		result2 error
	}
	getMFASecretReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetUserByEmailStub        func(context.Context, string) (*domain.User, error)
	getUserByEmailMutex       sync.RWMutex
	getUserByEmailArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getUserByEmailReturns struct {
		result1 *domain.User
		result2 error
	}
	getUserByEmailReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	GetUserByIDStub        func(context.Context, uuid.UUID) (*domain.User, error)
	getUserByIDMutex       sync.RWMutex
	getUserByIDArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	getUserByIDReturns struct {
		result1 *domain.User
		result2 error
	}
	getUserByIDReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	SetMFASecretStub        func(context.Context, uuid.UUID, string) error
	setMFASecretMutex       sync.RWMutex
	setMFASecretArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
		arg3 string
	}
	setMFASecretReturns struct {
		result1 error
	}
	setMFASecretReturnsOnCall map[int]struct {
		result1 error
	}
	UpdatePasswordStub        func(context.Context, uuid.UUID, string) error
	updatePasswordMutex       sync.RWMutex
	updatePasswordArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
		arg3 string
	}
	updatePasswordReturns struct {
		result1 error
	}
	updatePasswordReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateUserStub        func(context.Context, domain.User) (*domain.User, error)
	updateUserMutex       sync.RWMutex
	updateUserArgsForCall []struct {
		arg1 context.Context
		arg2 domain.User
	}
	updateUserReturns struct {
		result1 *domain.User
		result2 error
	}
	updateUserReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	UpdateUserAddressDetailsStub        func(context.Context, domain.User) (*domain.User, error)
	updateUserAddressDetailsMutex       sync.RWMutex
	updateUserAddressDetailsArgsForCall []struct {
		arg1 context.Context
		arg2 domain.User
	}
	updateUserAddressDetailsReturns struct {
		result1 *domain.User
		result2 error
	}
	updateUserAddressDetailsReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	UpdateUserBusinessDetailsStub        func(context.Context, domain.User) (*domain.User, error)
	updateUserBusinessDetailsMutex       sync.RWMutex
	updateUserBusinessDetailsArgsForCall []struct {
		arg1 context.Context
		arg2 domain.User
	}
	updateUserBusinessDetailsReturns struct {
		result1 *domain.User
		result2 error
	}
	updateUserBusinessDetailsReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	UpdateUserPersonalDetailsStub        func(context.Context, domain.User) (*domain.User, error)
	updateUserPersonalDetailsMutex       sync.RWMutex
	updateUserPersonalDetailsArgsForCall []struct {
		arg1 context.Context
		arg2 domain.User
	}
	updateUserPersonalDetailsReturns struct {
		result1 *domain.User
		result2 error
	}
	updateUserPersonalDetailsReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeUserRepository) CheckEmailExists(arg1 context.Context, arg2 string) (bool, error) {
	fake.checkEmailExistsMutex.Lock()
	ret, specificReturn := fake.checkEmailExistsReturnsOnCall[len(fake.checkEmailExistsArgsForCall)]
	fake.checkEmailExistsArgsForCall = append(fake.checkEmailExistsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.CheckEmailExistsStub
	fakeReturns := fake.checkEmailExistsReturns
	fake.recordInvocation("CheckEmailExists", []interface{}{arg1, arg2})
	fake.checkEmailExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) CheckEmailExistsCallCount() int {
	fake.checkEmailExistsMutex.RLock()
	defer fake.checkEmailExistsMutex.RUnlock()
	return len(fake.checkEmailExistsArgsForCall)
}

func (fake *FakeUserRepository) CheckEmailExistsCalls(stub func(context.Context, string) (bool, error)) {
	fake.checkEmailExistsMutex.Lock()
	defer fake.checkEmailExistsMutex.Unlock()
	fake.CheckEmailExistsStub = stub
}

func (fake *FakeUserRepository) CheckEmailExistsArgsForCall(i int) (context.Context, string) {
	fake.checkEmailExistsMutex.RLock()
	defer fake.checkEmailExistsMutex.RUnlock()
	argsForCall := fake.checkEmailExistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserRepository) CheckEmailExistsReturns(result1 bool, result2 error) {
	fake.checkEmailExistsMutex.Lock()
	defer fake.checkEmailExistsMutex.Unlock()
	fake.CheckEmailExistsStub = nil
	fake.checkEmailExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) CheckEmailExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.checkEmailExistsMutex.Lock()
	defer fake.checkEmailExistsMutex.Unlock()
	fake.CheckEmailExistsStub = nil
	if fake.checkEmailExistsReturnsOnCall == nil {
		fake.checkEmailExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkEmailExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) CreateUser(arg1 context.Context, arg2 domain.User) (*domain.User, error) {
	fake.createUserMutex.Lock()
	ret, specificReturn := fake.createUserReturnsOnCall[len(fake.createUserArgsForCall)]
	fake.createUserArgsForCall = append(fake.createUserArgsForCall, struct {
		arg1 context.Context
		arg2 domain.User
	}{arg1, arg2})
	stub := fake.CreateUserStub
	fakeReturns := fake.createUserReturns
	fake.recordInvocation("CreateUser", []interface{}{arg1, arg2})
	fake.createUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) CreateUserCallCount() int {
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	return len(fake.createUserArgsForCall)
}

func (fake *FakeUserRepository) CreateUserCalls(stub func(context.Context, domain.User) (*domain.User, error)) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = stub
}

func (fake *FakeUserRepository) CreateUserArgsForCall(i int) (context.Context, domain.User) {
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	argsForCall := fake.createUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserRepository) CreateUserReturns(result1 *domain.User, result2 error) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = nil
	fake.createUserReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) CreateUserReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = nil
	if fake.createUserReturnsOnCall == nil {
		fake.createUserReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.createUserReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) DeactivateUser(arg1 context.Context, arg2 uuid.UUID) error {
	fake.deactivateUserMutex.Lock()
	ret, specificReturn := fake.deactivateUserReturnsOnCall[len(fake.deactivateUserArgsForCall)]
	fake.deactivateUserArgsForCall = append(fake.deactivateUserArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.DeactivateUserStub
	fakeReturns := fake.deactivateUserReturns
	fake.recordInvocation("DeactivateUser", []interface{}{arg1, arg2})
	fake.deactivateUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUserRepository) DeactivateUserCallCount() int {
	fake.deactivateUserMutex.RLock()
	defer fake.deactivateUserMutex.RUnlock()
	return len(fake.deactivateUserArgsForCall)
}

func (fake *FakeUserRepository) DeactivateUserCalls(stub func(context.Context, uuid.UUID) error) {
	fake.deactivateUserMutex.Lock()
	defer fake.deactivateUserMutex.Unlock()
	fake.DeactivateUserStub = stub
}

func (fake *FakeUserRepository) DeactivateUserArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.deactivateUserMutex.RLock()
	defer fake.deactivateUserMutex.RUnlock()
	argsForCall := fake.deactivateUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserRepository) DeactivateUserReturns(result1 error) {
	fake.deactivateUserMutex.Lock()
	defer fake.deactivateUserMutex.Unlock()
	fake.DeactivateUserStub = nil
	fake.deactivateUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) DeactivateUserReturnsOnCall(i int, result1 error) {
	fake.deactivateUserMutex.Lock()
	defer fake.deactivateUserMutex.Unlock()
	fake.DeactivateUserStub = nil
	if fake.deactivateUserReturnsOnCall == nil {
		fake.deactivateUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deactivateUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) DeleteUser(arg1 context.Context, arg2 uuid.UUID) error {
	fake.deleteUserMutex.Lock()
	ret, specificReturn := fake.deleteUserReturnsOnCall[len(fake.deleteUserArgsForCall)]
	fake.deleteUserArgsForCall = append(fake.deleteUserArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.DeleteUserStub
	fakeReturns := fake.deleteUserReturns
	fake.recordInvocation("DeleteUser", []interface{}{arg1, arg2})
	fake.deleteUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUserRepository) DeleteUserCallCount() int {
	fake.deleteUserMutex.RLock()
	defer fake.deleteUserMutex.RUnlock()
	return len(fake.deleteUserArgsForCall)
}

func (fake *FakeUserRepository) DeleteUserCalls(stub func(context.Context, uuid.UUID) error) {
	fake.deleteUserMutex.Lock()
	defer fake.deleteUserMutex.Unlock()
	fake.DeleteUserStub = stub
}

func (fake *FakeUserRepository) DeleteUserArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.deleteUserMutex.RLock()
	defer fake.deleteUserMutex.RUnlock()
	argsForCall := fake.deleteUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserRepository) DeleteUserReturns(result1 error) {
	fake.deleteUserMutex.Lock()
	defer fake.deleteUserMutex.Unlock()
	fake.DeleteUserStub = nil
	fake.deleteUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) DeleteUserReturnsOnCall(i int, result1 error) {
	fake.deleteUserMutex.Lock()
	defer fake.deleteUserMutex.Unlock()
	fake.DeleteUserStub = nil
	if fake.deleteUserReturnsOnCall == nil {
		fake.deleteUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) GetMFASecret(arg1 context.Context, arg2 uuid.UUID) (string, error) {
	fake.getMFASecretMutex.Lock()
	ret, specificReturn := fake.getMFASecretReturnsOnCall[len(fake.getMFASecretArgsForCall)]
	fake.getMFASecretArgsForCall = append(fake.getMFASecretArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.GetMFASecretStub
	fakeReturns := fake.getMFASecretReturns
	fake.recordInvocation("GetMFASecret", []interface{}{arg1, arg2})
	fake.getMFASecretMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) GetMFASecretCallCount() int {
	fake.getMFASecretMutex.RLock()
	defer fake.getMFASecretMutex.RUnlock()
	return len(fake.getMFASecretArgsForCall)
}

func (fake *FakeUserRepository) GetMFASecretCalls(stub func(context.Context, uuid.UUID) (string, error)) {
	fake.getMFASecretMutex.Lock()
	defer fake.getMFASecretMutex.Unlock()
	fake.GetMFASecretStub = stub
}

func (fake *FakeUserRepository) GetMFASecretArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.getMFASecretMutex.RLock()
	defer fake.getMFASecretMutex.RUnlock()
	argsForCall := fake.getMFASecretArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserRepository) GetMFASecretReturns(result1 string, result2 error) {
	fake.getMFASecretMutex.Lock()
	defer fake.getMFASecretMutex.Unlock()
	fake.GetMFASecretStub = nil
	fake.getMFASecretReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) GetMFASecretReturnsOnCall(i int, result1 string, result2 error) {
	fake.getMFASecretMutex.Lock()
	defer fake.getMFASecretMutex.Unlock()
	fake.GetMFASecretStub = nil
	if fake.getMFASecretReturnsOnCall == nil {
		fake.getMFASecretReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getMFASecretReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) GetUserByEmail(arg1 context.Context, arg2 string) (*domain.User, error) {
	fake.getUserByEmailMutex.Lock()
	ret, specificReturn := fake.getUserByEmailReturnsOnCall[len(fake.getUserByEmailArgsForCall)]
	fake.getUserByEmailArgsForCall = append(fake.getUserByEmailArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetUserByEmailStub
	fakeReturns := fake.getUserByEmailReturns
	fake.recordInvocation("GetUserByEmail", []interface{}{arg1, arg2})
	fake.getUserByEmailMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) GetUserByEmailCallCount() int {
	fake.getUserByEmailMutex.RLock()
	defer fake.getUserByEmailMutex.RUnlock()
	return len(fake.getUserByEmailArgsForCall)
}

func (fake *FakeUserRepository) GetUserByEmailCalls(stub func(context.Context, string) (*domain.User, error)) {
	fake.getUserByEmailMutex.Lock()
	defer fake.getUserByEmailMutex.Unlock()
	fake.GetUserByEmailStub = stub
}

func (fake *FakeUserRepository) GetUserByEmailArgsForCall(i int) (context.Context, string) {
	fake.getUserByEmailMutex.RLock()
	defer fake.getUserByEmailMutex.RUnlock()
	argsForCall := fake.getUserByEmailArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserRepository) GetUserByEmailReturns(result1 *domain.User, result2 error) {
	fake.getUserByEmailMutex.Lock()
	defer fake.getUserByEmailMutex.Unlock()
	fake.GetUserByEmailStub = nil
	fake.getUserByEmailReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) GetUserByEmailReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.getUserByEmailMutex.Lock()
	defer fake.getUserByEmailMutex.Unlock()
	fake.GetUserByEmailStub = nil
	if fake.getUserByEmailReturnsOnCall == nil {
		fake.getUserByEmailReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.getUserByEmailReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) GetUserByID(arg1 context.Context, arg2 uuid.UUID) (*domain.User, error) {
	fake.getUserByIDMutex.Lock()
	ret, specificReturn := fake.getUserByIDReturnsOnCall[len(fake.getUserByIDArgsForCall)]
	fake.getUserByIDArgsForCall = append(fake.getUserByIDArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.GetUserByIDStub
	fakeReturns := fake.getUserByIDReturns
	fake.recordInvocation("GetUserByID", []interface{}{arg1, arg2})
	fake.getUserByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) GetUserByIDCallCount() int {
	fake.getUserByIDMutex.RLock()
	defer fake.getUserByIDMutex.RUnlock()
	return len(fake.getUserByIDArgsForCall)
}

func (fake *FakeUserRepository) GetUserByIDCalls(stub func(context.Context, uuid.UUID) (*domain.User, error)) {
	fake.getUserByIDMutex.Lock()
	defer fake.getUserByIDMutex.Unlock()
	fake.GetUserByIDStub = stub
}

func (fake *FakeUserRepository) GetUserByIDArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.getUserByIDMutex.RLock()
	defer fake.getUserByIDMutex.RUnlock()
	argsForCall := fake.getUserByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserRepository) GetUserByIDReturns(result1 *domain.User, result2 error) {
	fake.getUserByIDMutex.Lock()
	defer fake.getUserByIDMutex.Unlock()
	fake.GetUserByIDStub = nil
	fake.getUserByIDReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) GetUserByIDReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.getUserByIDMutex.Lock()
	defer fake.getUserByIDMutex.Unlock()
	fake.GetUserByIDStub = nil
	if fake.getUserByIDReturnsOnCall == nil {
		fake.getUserByIDReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.getUserByIDReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) SetMFASecret(arg1 context.Context, arg2 uuid.UUID, arg3 string) error {
	fake.setMFASecretMutex.Lock()
	ret, specificReturn := fake.setMFASecretReturnsOnCall[len(fake.setMFASecretArgsForCall)]
	fake.setMFASecretArgsForCall = append(fake.setMFASecretArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.SetMFASecretStub
	fakeReturns := fake.setMFASecretReturns
	fake.recordInvocation("SetMFASecret", []interface{}{arg1, arg2, arg3})
	fake.setMFASecretMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUserRepository) SetMFASecretCallCount() int {
	fake.setMFASecretMutex.RLock()
	defer fake.setMFASecretMutex.RUnlock()
	return len(fake.setMFASecretArgsForCall)
}

func (fake *FakeUserRepository) SetMFASecretCalls(stub func(context.Context, uuid.UUID, string) error) {
	fake.setMFASecretMutex.Lock()
	defer fake.setMFASecretMutex.Unlock()
	fake.SetMFASecretStub = stub
}

func (fake *FakeUserRepository) SetMFASecretArgsForCall(i int) (context.Context, uuid.UUID, string) {
	fake.setMFASecretMutex.RLock()
	defer fake.setMFASecretMutex.RUnlock()
	argsForCall := fake.setMFASecretArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUserRepository) SetMFASecretReturns(result1 error) {
	fake.setMFASecretMutex.Lock()
	defer fake.setMFASecretMutex.Unlock()
	fake.SetMFASecretStub = nil
	fake.setMFASecretReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) SetMFASecretReturnsOnCall(i int, result1 error) {
	fake.setMFASecretMutex.Lock()
	defer fake.setMFASecretMutex.Unlock()
	fake.SetMFASecretStub = nil
	if fake.setMFASecretReturnsOnCall == nil {
		fake.setMFASecretReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setMFASecretReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) UpdatePassword(arg1 context.Context, arg2 uuid.UUID, arg3 string) error {
	fake.updatePasswordMutex.Lock()
	ret, specificReturn := fake.updatePasswordReturnsOnCall[len(fake.updatePasswordArgsForCall)]
	fake.updatePasswordArgsForCall = append(fake.updatePasswordArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.UpdatePasswordStub
	fakeReturns := fake.updatePasswordReturns
	fake.recordInvocation("UpdatePassword", []interface{}{arg1, arg2, arg3})
	fake.updatePasswordMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUserRepository) UpdatePasswordCallCount() int {
	fake.updatePasswordMutex.RLock()
	defer fake.updatePasswordMutex.RUnlock()
	return len(fake.updatePasswordArgsForCall)
}

func (fake *FakeUserRepository) UpdatePasswordCalls(stub func(context.Context, uuid.UUID, string) error) {
	fake.updatePasswordMutex.Lock()
	defer fake.updatePasswordMutex.Unlock()
	fake.UpdatePasswordStub = stub
}

func (fake *FakeUserRepository) UpdatePasswordArgsForCall(i int) (context.Context, uuid.UUID, string) {
	fake.updatePasswordMutex.RLock()
	defer fake.updatePasswordMutex.RUnlock()
	argsForCall := fake.updatePasswordArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUserRepository) UpdatePasswordReturns(result1 error) {
	fake.updatePasswordMutex.Lock()
	defer fake.updatePasswordMutex.Unlock()
	fake.UpdatePasswordStub = nil
	fake.updatePasswordReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) UpdatePasswordReturnsOnCall(i int, result1 error) {
	fake.updatePasswordMutex.Lock()
	defer fake.updatePasswordMutex.Unlock()
	fake.UpdatePasswordStub = nil
	if fake.updatePasswordReturnsOnCall == nil {
		fake.updatePasswordReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updatePasswordReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) UpdateUser(arg1 context.Context, arg2 domain.User) (*domain.User, error) {
	fake.updateUserMutex.Lock()
	ret, specificReturn := fake.updateUserReturnsOnCall[len(fake.updateUserArgsForCall)]
	fake.updateUserArgsForCall = append(fake.updateUserArgsForCall, struct {
		arg1 context.Context
		arg2 domain.User
	}{arg1, arg2})
	stub := fake.UpdateUserStub
	fakeReturns := fake.updateUserReturns
	fake.recordInvocation("UpdateUser", []interface{}{arg1, arg2})
	fake.updateUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) UpdateUserCallCount() int {
	fake.updateUserMutex.RLock()
	defer fake.updateUserMutex.RUnlock()
	return len(fake.updateUserArgsForCall)
}

func (fake *FakeUserRepository) UpdateUserCalls(stub func(context.Context, domain.User) (*domain.User, error)) {
	fake.updateUserMutex.Lock()
	defer fake.updateUserMutex.Unlock()
	fake.UpdateUserStub = stub
}

func (fake *FakeUserRepository) UpdateUserArgsForCall(i int) (context.Context, domain.User) {
	fake.updateUserMutex.RLock()
	defer fake.updateUserMutex.RUnlock()
	argsForCall := fake.updateUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserRepository) UpdateUserReturns(result1 *domain.User, result2 error) {
	fake.updateUserMutex.Lock()
	defer fake.updateUserMutex.Unlock()
	fake.UpdateUserStub = nil
	fake.updateUserReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) UpdateUserReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.updateUserMutex.Lock()
	defer fake.updateUserMutex.Unlock()
	fake.UpdateUserStub = nil
	if fake.updateUserReturnsOnCall == nil {
		fake.updateUserReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.updateUserReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) UpdateUserAddressDetails(arg1 context.Context, arg2 domain.User) (*domain.User, error) {
	fake.updateUserAddressDetailsMutex.Lock()
	ret, specificReturn := fake.updateUserAddressDetailsReturnsOnCall[len(fake.updateUserAddressDetailsArgsForCall)]
	fake.updateUserAddressDetailsArgsForCall = append(fake.updateUserAddressDetailsArgsForCall, struct {
		arg1 context.Context
		arg2 domain.User
	}{arg1, arg2})
	stub := fake.UpdateUserAddressDetailsStub
	fakeReturns := fake.updateUserAddressDetailsReturns
	fake.recordInvocation("UpdateUserAddressDetails", []interface{}{arg1, arg2})
	fake.updateUserAddressDetailsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) UpdateUserAddressDetailsCallCount() int {
	fake.updateUserAddressDetailsMutex.RLock()
	defer fake.updateUserAddressDetailsMutex.RUnlock()
	return len(fake.updateUserAddressDetailsArgsForCall)
}

func (fake *FakeUserRepository) UpdateUserAddressDetailsCalls(stub func(context.Context, domain.User) (*domain.User, error)) {
	fake.updateUserAddressDetailsMutex.Lock()
	defer fake.updateUserAddressDetailsMutex.Unlock()
	fake.UpdateUserAddressDetailsStub = stub
}

func (fake *FakeUserRepository) UpdateUserAddressDetailsArgsForCall(i int) (context.Context, domain.User) {
	fake.updateUserAddressDetailsMutex.RLock()
	defer fake.updateUserAddressDetailsMutex.RUnlock()
	argsForCall := fake.updateUserAddressDetailsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserRepository) UpdateUserAddressDetailsReturns(result1 *domain.User, result2 error) {
	fake.updateUserAddressDetailsMutex.Lock()
	defer fake.updateUserAddressDetailsMutex.Unlock()
	fake.UpdateUserAddressDetailsStub = nil
	fake.updateUserAddressDetailsReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) UpdateUserAddressDetailsReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.updateUserAddressDetailsMutex.Lock()
	defer fake.updateUserAddressDetailsMutex.Unlock()
	fake.UpdateUserAddressDetailsStub = nil
	if fake.updateUserAddressDetailsReturnsOnCall == nil {
		fake.updateUserAddressDetailsReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.updateUserAddressDetailsReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) UpdateUserBusinessDetails(arg1 context.Context, arg2 domain.User) (*domain.User, error) {
	fake.updateUserBusinessDetailsMutex.Lock()
	ret, specificReturn := fake.updateUserBusinessDetailsReturnsOnCall[len(fake.updateUserBusinessDetailsArgsForCall)]
	fake.updateUserBusinessDetailsArgsForCall = append(fake.updateUserBusinessDetailsArgsForCall, struct {
		arg1 context.Context
		arg2 domain.User
	}{arg1, arg2})
	stub := fake.UpdateUserBusinessDetailsStub
	fakeReturns := fake.updateUserBusinessDetailsReturns
	fake.recordInvocation("UpdateUserBusinessDetails", []interface{}{arg1, arg2})
	fake.updateUserBusinessDetailsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) UpdateUserBusinessDetailsCallCount() int {
	fake.updateUserBusinessDetailsMutex.RLock()
	defer fake.updateUserBusinessDetailsMutex.RUnlock()
	return len(fake.updateUserBusinessDetailsArgsForCall)
}

func (fake *FakeUserRepository) UpdateUserBusinessDetailsCalls(stub func(context.Context, domain.User) (*domain.User, error)) {
	fake.updateUserBusinessDetailsMutex.Lock()
	defer fake.updateUserBusinessDetailsMutex.Unlock()
	fake.UpdateUserBusinessDetailsStub = stub
}

func (fake *FakeUserRepository) UpdateUserBusinessDetailsArgsForCall(i int) (context.Context, domain.User) {
	fake.updateUserBusinessDetailsMutex.RLock()
	defer fake.updateUserBusinessDetailsMutex.RUnlock()
	argsForCall := fake.updateUserBusinessDetailsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserRepository) UpdateUserBusinessDetailsReturns(result1 *domain.User, result2 error) {
	fake.updateUserBusinessDetailsMutex.Lock()
	defer fake.updateUserBusinessDetailsMutex.Unlock()
	fake.UpdateUserBusinessDetailsStub = nil
	fake.updateUserBusinessDetailsReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) UpdateUserBusinessDetailsReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.updateUserBusinessDetailsMutex.Lock()
	defer fake.updateUserBusinessDetailsMutex.Unlock()
	fake.UpdateUserBusinessDetailsStub = nil
	if fake.updateUserBusinessDetailsReturnsOnCall == nil {
		fake.updateUserBusinessDetailsReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.updateUserBusinessDetailsReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) UpdateUserPersonalDetails(arg1 context.Context, arg2 domain.User) (*domain.User, error) {
	fake.updateUserPersonalDetailsMutex.Lock()
	ret, specificReturn := fake.updateUserPersonalDetailsReturnsOnCall[len(fake.updateUserPersonalDetailsArgsForCall)]
	fake.updateUserPersonalDetailsArgsForCall = append(fake.updateUserPersonalDetailsArgsForCall, struct {
		arg1 context.Context
		arg2 domain.User
	}{arg1, arg2})
	stub := fake.UpdateUserPersonalDetailsStub
	fakeReturns := fake.updateUserPersonalDetailsReturns
	fake.recordInvocation("UpdateUserPersonalDetails", []interface{}{arg1, arg2})
	fake.updateUserPersonalDetailsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) UpdateUserPersonalDetailsCallCount() int {
	fake.updateUserPersonalDetailsMutex.RLock()
	defer fake.updateUserPersonalDetailsMutex.RUnlock()
	return len(fake.updateUserPersonalDetailsArgsForCall)
}

func (fake *FakeUserRepository) UpdateUserPersonalDetailsCalls(stub func(context.Context, domain.User) (*domain.User, error)) {
	fake.updateUserPersonalDetailsMutex.Lock()
	defer fake.updateUserPersonalDetailsMutex.Unlock()
	fake.UpdateUserPersonalDetailsStub = stub
}

func (fake *FakeUserRepository) UpdateUserPersonalDetailsArgsForCall(i int) (context.Context, domain.User) {
	fake.updateUserPersonalDetailsMutex.RLock()
	defer fake.updateUserPersonalDetailsMutex.RUnlock()
	argsForCall := fake.updateUserPersonalDetailsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserRepository) UpdateUserPersonalDetailsReturns(result1 *domain.User, result2 error) {
	fake.updateUserPersonalDetailsMutex.Lock()
	defer fake.updateUserPersonalDetailsMutex.Unlock()
	fake.UpdateUserPersonalDetailsStub = nil
	fake.updateUserPersonalDetailsReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) UpdateUserPersonalDetailsReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.updateUserPersonalDetailsMutex.Lock()
	defer fake.updateUserPersonalDetailsMutex.Unlock()
	fake.UpdateUserPersonalDetailsStub = nil
	if fake.updateUserPersonalDetailsReturnsOnCall == nil {
		fake.updateUserPersonalDetailsReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.updateUserPersonalDetailsReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.checkEmailExistsMutex.RLock()
	defer fake.checkEmailExistsMutex.RUnlock()
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	fake.deactivateUserMutex.RLock()
	defer fake.deactivateUserMutex.RUnlock()
	fake.deleteUserMutex.RLock()
	defer fake.deleteUserMutex.RUnlock()
	fake.getMFASecretMutex.RLock()
	defer fake.getMFASecretMutex.RUnlock()
	fake.getUserByEmailMutex.RLock()
	defer fake.getUserByEmailMutex.RUnlock()
	fake.getUserByIDMutex.RLock()
	defer fake.getUserByIDMutex.RUnlock()
	fake.setMFASecretMutex.RLock()
	defer fake.setMFASecretMutex.RUnlock()
	fake.updatePasswordMutex.RLock()
	defer fake.updatePasswordMutex.RUnlock()
	fake.updateUserMutex.RLock()
	defer fake.updateUserMutex.RUnlock()
	fake.updateUserAddressDetailsMutex.RLock()
	defer fake.updateUserAddressDetailsMutex.RUnlock()
	fake.updateUserBusinessDetailsMutex.RLock()
	defer fake.updateUserBusinessDetailsMutex.RUnlock()
	fake.updateUserPersonalDetailsMutex.RLock()
	defer fake.updateUserPersonalDetailsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeUserRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ports.UserRepository = new(FakeUserRepository)
