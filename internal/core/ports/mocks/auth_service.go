// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/demola234/defifundr/internal/core/domain"
	"github.com/demola234/defifundr/internal/core/ports"
	"github.com/google/uuid"
)

type FakeAuthService struct {
	AuthenticateWithWeb3Stub        func(context.Context, string, string, string) (*domain.User, *domain.Session, error)
	authenticateWithWeb3Mutex       sync.RWMutex
	authenticateWithWeb3ArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	authenticateWithWeb3Returns struct {
		result1 *domain.User
		result2 *domain.Session
		result3 error
	}
	authenticateWithWeb3ReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 *domain.Session
		result3 error
	}
	CheckEmailExistsStub        func(context.Context, string) (bool, error)
	checkEmailExistsMutex       sync.RWMutex
	checkEmailExistsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	checkEmailExistsReturns struct {
		result1 bool
		result2 error
	}
	checkEmailExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CreateSessionStub        func(context.Context, uuid.UUID, string, string, string, string, string) (*domain.Session, error)
	createSessionMutex       sync.RWMutex
	createSessionArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 string
	}
	createSessionReturns struct {
		result1 *domain.Session
		result2 error
	}
	createSessionReturnsOnCall map[int]struct {
		result1 *domain.Session
		result2 error
	}
	GetActiveDevicesStub        func(context.Context, uuid.UUID) ([]domain.DeviceInfo, error)
	getActiveDevicesMutex       sync.RWMutex
	getActiveDevicesArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	getActiveDevicesReturns struct {
		result1 []domain.DeviceInfo
		result2 error
	}
	getActiveDevicesReturnsOnCall map[int]struct {
		result1 []domain.DeviceInfo
		result2 error
	}
	GetProfileCompletionStatusStub        func(context.Context, uuid.UUID) (*domain.ProfileCompletion, error)
	getProfileCompletionStatusMutex       sync.RWMutex
	getProfileCompletionStatusArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	getProfileCompletionStatusReturns struct {
		result1 *domain.ProfileCompletion
		result2 error
	}
	getProfileCompletionStatusReturnsOnCall map[int]struct {
		result1 *domain.ProfileCompletion
		result2 error
	}
	GetUserByEmailStub        func(context.Context, string) (*domain.User, error)
	getUserByEmailMutex       sync.RWMutex
	getUserByEmailArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getUserByEmailReturns struct {
		result1 *domain.User
		result2 error
	}
	getUserByEmailReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	GetUserByIDStub        func(context.Context, uuid.UUID) (*domain.User, error)
	getUserByIDMutex       sync.RWMutex
	getUserByIDArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	getUserByIDReturns struct {
		result1 *domain.User
		result2 error
	}
	getUserByIDReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	GetUserWalletsStub        func(context.Context, uuid.UUID) ([]domain.UserWallet, error)
	getUserWalletsMutex       sync.RWMutex
	getUserWalletsArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	getUserWalletsReturns struct {
		result1 []domain.UserWallet
		result2 error
	}
	getUserWalletsReturnsOnCall map[int]struct {
		result1 []domain.UserWallet
		result2 error
	}
	LinkWalletStub        func(context.Context, uuid.UUID, string, string, string) error
	linkWalletMutex       sync.RWMutex
	linkWalletArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
		arg3 string
		arg4 string
		arg5 string
	}
	linkWalletReturns struct {
		result1 error
	}
	linkWalletReturnsOnCall map[int]struct {
		result1 error
	}
	LogSecurityEventStub        func(context.Context, string, uuid.UUID, map[string]interface{}) error
	logSecurityEventMutex       sync.RWMutex
	logSecurityEventArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 uuid.UUID
		arg4 map[string]interface{}
	}
	logSecurityEventReturns struct {
		result1 error
	}
	logSecurityEventReturnsOnCall map[int]struct {
		result1 error
	}
	LoginStub        func(context.Context, string, domain.User, string) (*domain.User, error)
	loginMutex       sync.RWMutex
	loginArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 domain.User
		arg4 string
	}
	loginReturns struct {
		result1 *domain.User
		result2 error
	}
	loginReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	LogoutStub        func(context.Context, uuid.UUID) error
	logoutMutex       sync.RWMutex
	logoutArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	logoutReturns struct {
		result1 error
	}
	logoutReturnsOnCall map[int]struct {
		result1 error
	}
	RefreshTokenStub        func(context.Context, string, string, string) (*domain.Session, string, error)
	refreshTokenMutex       sync.RWMutex
	refreshTokenArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	refreshTokenReturns struct {
		result1 *domain.Session
		result2 string
		result3 error
	}
	refreshTokenReturnsOnCall map[int]struct {
		result1 *domain.Session
		result2 string
		result3 error
	}
	RegisterAddressDetailsStub        func(context.Context, domain.User) (*domain.User, error)
	registerAddressDetailsMutex       sync.RWMutex
	registerAddressDetailsArgsForCall []struct {
		arg1 context.Context
		arg2 domain.User
	}
	registerAddressDetailsReturns struct {
		result1 *domain.User
		result2 error
	}
	registerAddressDetailsReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	RegisterBusinessDetailsStub        func(context.Context, domain.User) (*domain.User, error)
	registerBusinessDetailsMutex       sync.RWMutex
	registerBusinessDetailsArgsForCall []struct {
		arg1 context.Context
		arg2 domain.User
	}
	registerBusinessDetailsReturns struct {
		result1 *domain.User
		result2 error
	}
	registerBusinessDetailsReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	RegisterPersonalDetailsStub        func(context.Context, domain.User) (*domain.User, error)
	registerPersonalDetailsMutex       sync.RWMutex
	registerPersonalDetailsArgsForCall []struct {
		arg1 context.Context
		arg2 domain.User
	}
	registerPersonalDetailsReturns struct {
		result1 *domain.User
		result2 error
	}
	registerPersonalDetailsReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	RegisterUserStub        func(context.Context, domain.User, string) (*domain.User, error)
	registerUserMutex       sync.RWMutex
	registerUserArgsForCall []struct {
		arg1 context.Context
		arg2 domain.User
		arg3 string
	}
	registerUserReturns struct {
		result1 *domain.User
		result2 error
	}
	registerUserReturnsOnCall map[int]struct {
		result1 *domain.User
		result2 error
	}
	RevokeSessionStub        func(context.Context, uuid.UUID, uuid.UUID) error
	revokeSessionMutex       sync.RWMutex
	revokeSessionArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
		arg3 uuid.UUID
	}
	revokeSessionReturns struct {
		result1 error
	}
	revokeSessionReturnsOnCall map[int]struct {
		result1 error
	}
	SetupMFAStub        func(context.Context, uuid.UUID) (string, error)
	setupMFAMutex       sync.RWMutex
	setupMFAArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	setupMFAReturns struct {
		result1 string
		result2 error
	}
	setupMFAReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	VerifyMFAStub        func(context.Context, uuid.UUID, string) (bool, error)
	verifyMFAMutex       sync.RWMutex
	verifyMFAArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
		arg3 string
	}
	verifyMFAReturns struct {
		result1 bool
		result2 error
	}
	verifyMFAReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAuthService) AuthenticateWithWeb3(arg1 context.Context, arg2 string, arg3 string, arg4 string) (*domain.User, *domain.Session, error) {
	fake.authenticateWithWeb3Mutex.Lock()
	ret, specificReturn := fake.authenticateWithWeb3ReturnsOnCall[len(fake.authenticateWithWeb3ArgsForCall)]
	fake.authenticateWithWeb3ArgsForCall = append(fake.authenticateWithWeb3ArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.AuthenticateWithWeb3Stub
	fakeReturns := fake.authenticateWithWeb3Returns
	fake.recordInvocation("AuthenticateWithWeb3", []interface{}{arg1, arg2, arg3, arg4})
	fake.authenticateWithWeb3Mutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeAuthService) AuthenticateWithWeb3CallCount() int {
	fake.authenticateWithWeb3Mutex.RLock()
	defer fake.authenticateWithWeb3Mutex.RUnlock()
	return len(fake.authenticateWithWeb3ArgsForCall)
}

func (fake *FakeAuthService) AuthenticateWithWeb3Calls(stub func(context.Context, string, string, string) (*domain.User, *domain.Session, error)) {
	fake.authenticateWithWeb3Mutex.Lock()
	defer fake.authenticateWithWeb3Mutex.Unlock()
	fake.AuthenticateWithWeb3Stub = stub
}

func (fake *FakeAuthService) AuthenticateWithWeb3ArgsForCall(i int) (context.Context, string, string, string) {
	fake.authenticateWithWeb3Mutex.RLock()
	defer fake.authenticateWithWeb3Mutex.RUnlock()
	argsForCall := fake.authenticateWithWeb3ArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeAuthService) AuthenticateWithWeb3Returns(result1 *domain.User, result2 *domain.Session, result3 error) {
	fake.authenticateWithWeb3Mutex.Lock()
	defer fake.authenticateWithWeb3Mutex.Unlock()
	fake.AuthenticateWithWeb3Stub = nil
	fake.authenticateWithWeb3Returns = struct {
		result1 *domain.User
		result2 *domain.Session
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAuthService) AuthenticateWithWeb3ReturnsOnCall(i int, result1 *domain.User, result2 *domain.Session, result3 error) {
	fake.authenticateWithWeb3Mutex.Lock()
	defer fake.authenticateWithWeb3Mutex.Unlock()
	fake.AuthenticateWithWeb3Stub = nil
	if fake.authenticateWithWeb3ReturnsOnCall == nil {
		fake.authenticateWithWeb3ReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 *domain.Session
			result3 error
		})
	}
	fake.authenticateWithWeb3ReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 *domain.Session
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAuthService) CheckEmailExists(arg1 context.Context, arg2 string) (bool, error) {
	fake.checkEmailExistsMutex.Lock()
	ret, specificReturn := fake.checkEmailExistsReturnsOnCall[len(fake.checkEmailExistsArgsForCall)]
	fake.checkEmailExistsArgsForCall = append(fake.checkEmailExistsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.CheckEmailExistsStub
	fakeReturns := fake.checkEmailExistsReturns
	fake.recordInvocation("CheckEmailExists", []interface{}{arg1, arg2})
	fake.checkEmailExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) CheckEmailExistsCallCount() int {
	fake.checkEmailExistsMutex.RLock()
	defer fake.checkEmailExistsMutex.RUnlock()
	return len(fake.checkEmailExistsArgsForCall)
}

func (fake *FakeAuthService) CheckEmailExistsCalls(stub func(context.Context, string) (bool, error)) {
	fake.checkEmailExistsMutex.Lock()
	defer fake.checkEmailExistsMutex.Unlock()
	fake.CheckEmailExistsStub = stub
}

func (fake *FakeAuthService) CheckEmailExistsArgsForCall(i int) (context.Context, string) {
	fake.checkEmailExistsMutex.RLock()
	defer fake.checkEmailExistsMutex.RUnlock()
	argsForCall := fake.checkEmailExistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) CheckEmailExistsReturns(result1 bool, result2 error) {
	fake.checkEmailExistsMutex.Lock()
	defer fake.checkEmailExistsMutex.Unlock()
	fake.CheckEmailExistsStub = nil
	fake.checkEmailExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) CheckEmailExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.checkEmailExistsMutex.Lock()
	defer fake.checkEmailExistsMutex.Unlock()
	fake.CheckEmailExistsStub = nil
	if fake.checkEmailExistsReturnsOnCall == nil {
		fake.checkEmailExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkEmailExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) CreateSession(arg1 context.Context, arg2 uuid.UUID, arg3 string, arg4 string, arg5 string, arg6 string, arg7 string) (*domain.Session, error) {
	fake.createSessionMutex.Lock()
	ret, specificReturn := fake.createSessionReturnsOnCall[len(fake.createSessionArgsForCall)]
	fake.createSessionArgsForCall = append(fake.createSessionArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	stub := fake.CreateSessionStub
	fakeReturns := fake.createSessionReturns
	fake.recordInvocation("CreateSession", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.createSessionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) CreateSessionCallCount() int {
	fake.createSessionMutex.RLock()
	defer fake.createSessionMutex.RUnlock()
	return len(fake.createSessionArgsForCall)
}

func (fake *FakeAuthService) CreateSessionCalls(stub func(context.Context, uuid.UUID, string, string, string, string, string) (*domain.Session, error)) {
	fake.createSessionMutex.Lock()
	defer fake.createSessionMutex.Unlock()
	fake.CreateSessionStub = stub
}

func (fake *FakeAuthService) CreateSessionArgsForCall(i int) (context.Context, uuid.UUID, string, string, string, string, string) {
	fake.createSessionMutex.RLock()
	defer fake.createSessionMutex.RUnlock()
	argsForCall := fake.createSessionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeAuthService) CreateSessionReturns(result1 *domain.Session, result2 error) {
	fake.createSessionMutex.Lock()
	defer fake.createSessionMutex.Unlock()
	fake.CreateSessionStub = nil
	fake.createSessionReturns = struct {
		result1 *domain.Session
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) CreateSessionReturnsOnCall(i int, result1 *domain.Session, result2 error) {
	fake.createSessionMutex.Lock()
	defer fake.createSessionMutex.Unlock()
	fake.CreateSessionStub = nil
	if fake.createSessionReturnsOnCall == nil {
		fake.createSessionReturnsOnCall = make(map[int]struct {
			result1 *domain.Session
			result2 error
		})
	}
	fake.createSessionReturnsOnCall[i] = struct {
		result1 *domain.Session
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) GetActiveDevices(arg1 context.Context, arg2 uuid.UUID) ([]domain.DeviceInfo, error) {
	fake.getActiveDevicesMutex.Lock()
	ret, specificReturn := fake.getActiveDevicesReturnsOnCall[len(fake.getActiveDevicesArgsForCall)]
	fake.getActiveDevicesArgsForCall = append(fake.getActiveDevicesArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.GetActiveDevicesStub
	fakeReturns := fake.getActiveDevicesReturns
	fake.recordInvocation("GetActiveDevices", []interface{}{arg1, arg2})
	fake.getActiveDevicesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) GetActiveDevicesCallCount() int {
	fake.getActiveDevicesMutex.RLock()
	defer fake.getActiveDevicesMutex.RUnlock()
	return len(fake.getActiveDevicesArgsForCall)
}

func (fake *FakeAuthService) GetActiveDevicesCalls(stub func(context.Context, uuid.UUID) ([]domain.DeviceInfo, error)) {
	fake.getActiveDevicesMutex.Lock()
	defer fake.getActiveDevicesMutex.Unlock()
	fake.GetActiveDevicesStub = stub
}

func (fake *FakeAuthService) GetActiveDevicesArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.getActiveDevicesMutex.RLock()
	defer fake.getActiveDevicesMutex.RUnlock()
	argsForCall := fake.getActiveDevicesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) GetActiveDevicesReturns(result1 []domain.DeviceInfo, result2 error) {
	fake.getActiveDevicesMutex.Lock()
	defer fake.getActiveDevicesMutex.Unlock()
	fake.GetActiveDevicesStub = nil
	fake.getActiveDevicesReturns = struct {
		result1 []domain.DeviceInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) GetActiveDevicesReturnsOnCall(i int, result1 []domain.DeviceInfo, result2 error) {
	fake.getActiveDevicesMutex.Lock()
	defer fake.getActiveDevicesMutex.Unlock()
	fake.GetActiveDevicesStub = nil
	if fake.getActiveDevicesReturnsOnCall == nil {
		fake.getActiveDevicesReturnsOnCall = make(map[int]struct {
			result1 []domain.DeviceInfo
			result2 error
		})
	}
	fake.getActiveDevicesReturnsOnCall[i] = struct {
		result1 []domain.DeviceInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) GetProfileCompletionStatus(arg1 context.Context, arg2 uuid.UUID) (*domain.ProfileCompletion, error) {
	fake.getProfileCompletionStatusMutex.Lock()
	ret, specificReturn := fake.getProfileCompletionStatusReturnsOnCall[len(fake.getProfileCompletionStatusArgsForCall)]
	fake.getProfileCompletionStatusArgsForCall = append(fake.getProfileCompletionStatusArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.GetProfileCompletionStatusStub
	fakeReturns := fake.getProfileCompletionStatusReturns
	fake.recordInvocation("GetProfileCompletionStatus", []interface{}{arg1, arg2})
	fake.getProfileCompletionStatusMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) GetProfileCompletionStatusCallCount() int {
	fake.getProfileCompletionStatusMutex.RLock()
	defer fake.getProfileCompletionStatusMutex.RUnlock()
	return len(fake.getProfileCompletionStatusArgsForCall)
}

func (fake *FakeAuthService) GetProfileCompletionStatusCalls(stub func(context.Context, uuid.UUID) (*domain.ProfileCompletion, error)) {
	fake.getProfileCompletionStatusMutex.Lock()
	defer fake.getProfileCompletionStatusMutex.Unlock()
	fake.GetProfileCompletionStatusStub = stub
}

func (fake *FakeAuthService) GetProfileCompletionStatusArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.getProfileCompletionStatusMutex.RLock()
	defer fake.getProfileCompletionStatusMutex.RUnlock()
	argsForCall := fake.getProfileCompletionStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) GetProfileCompletionStatusReturns(result1 *domain.ProfileCompletion, result2 error) {
	fake.getProfileCompletionStatusMutex.Lock()
	defer fake.getProfileCompletionStatusMutex.Unlock()
	fake.GetProfileCompletionStatusStub = nil
	fake.getProfileCompletionStatusReturns = struct {
		result1 *domain.ProfileCompletion
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) GetProfileCompletionStatusReturnsOnCall(i int, result1 *domain.ProfileCompletion, result2 error) {
	fake.getProfileCompletionStatusMutex.Lock()
	defer fake.getProfileCompletionStatusMutex.Unlock()
	fake.GetProfileCompletionStatusStub = nil
	if fake.getProfileCompletionStatusReturnsOnCall == nil {
		fake.getProfileCompletionStatusReturnsOnCall = make(map[int]struct {
			result1 *domain.ProfileCompletion
			result2 error
		})
	}
	fake.getProfileCompletionStatusReturnsOnCall[i] = struct {
		result1 *domain.ProfileCompletion
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) GetUserByEmail(arg1 context.Context, arg2 string) (*domain.User, error) {
	fake.getUserByEmailMutex.Lock()
	ret, specificReturn := fake.getUserByEmailReturnsOnCall[len(fake.getUserByEmailArgsForCall)]
	fake.getUserByEmailArgsForCall = append(fake.getUserByEmailArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetUserByEmailStub
	fakeReturns := fake.getUserByEmailReturns
	fake.recordInvocation("GetUserByEmail", []interface{}{arg1, arg2})
	fake.getUserByEmailMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) GetUserByEmailCallCount() int {
	fake.getUserByEmailMutex.RLock()
	defer fake.getUserByEmailMutex.RUnlock()
	return len(fake.getUserByEmailArgsForCall)
}

func (fake *FakeAuthService) GetUserByEmailCalls(stub func(context.Context, string) (*domain.User, error)) {
	fake.getUserByEmailMutex.Lock()
	defer fake.getUserByEmailMutex.Unlock()
	fake.GetUserByEmailStub = stub
}

func (fake *FakeAuthService) GetUserByEmailArgsForCall(i int) (context.Context, string) {
	fake.getUserByEmailMutex.RLock()
	defer fake.getUserByEmailMutex.RUnlock()
	argsForCall := fake.getUserByEmailArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) GetUserByEmailReturns(result1 *domain.User, result2 error) {
	fake.getUserByEmailMutex.Lock()
	defer fake.getUserByEmailMutex.Unlock()
	fake.GetUserByEmailStub = nil
	fake.getUserByEmailReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) GetUserByEmailReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.getUserByEmailMutex.Lock()
	defer fake.getUserByEmailMutex.Unlock()
	fake.GetUserByEmailStub = nil
	if fake.getUserByEmailReturnsOnCall == nil {
		fake.getUserByEmailReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.getUserByEmailReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) GetUserByID(arg1 context.Context, arg2 uuid.UUID) (*domain.User, error) {
	fake.getUserByIDMutex.Lock()
	ret, specificReturn := fake.getUserByIDReturnsOnCall[len(fake.getUserByIDArgsForCall)]
	fake.getUserByIDArgsForCall = append(fake.getUserByIDArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.GetUserByIDStub
	fakeReturns := fake.getUserByIDReturns
	fake.recordInvocation("GetUserByID", []interface{}{arg1, arg2})
	fake.getUserByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) GetUserByIDCallCount() int {
	fake.getUserByIDMutex.RLock()
	defer fake.getUserByIDMutex.RUnlock()
	return len(fake.getUserByIDArgsForCall)
}

func (fake *FakeAuthService) GetUserByIDCalls(stub func(context.Context, uuid.UUID) (*domain.User, error)) {
	fake.getUserByIDMutex.Lock()
	defer fake.getUserByIDMutex.Unlock()
	fake.GetUserByIDStub = stub
}

func (fake *FakeAuthService) GetUserByIDArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.getUserByIDMutex.RLock()
	defer fake.getUserByIDMutex.RUnlock()
	argsForCall := fake.getUserByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) GetUserByIDReturns(result1 *domain.User, result2 error) {
	fake.getUserByIDMutex.Lock()
	defer fake.getUserByIDMutex.Unlock()
	fake.GetUserByIDStub = nil
	fake.getUserByIDReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) GetUserByIDReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.getUserByIDMutex.Lock()
	defer fake.getUserByIDMutex.Unlock()
	fake.GetUserByIDStub = nil
	if fake.getUserByIDReturnsOnCall == nil {
		fake.getUserByIDReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.getUserByIDReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) GetUserWallets(arg1 context.Context, arg2 uuid.UUID) ([]domain.UserWallet, error) {
	fake.getUserWalletsMutex.Lock()
	ret, specificReturn := fake.getUserWalletsReturnsOnCall[len(fake.getUserWalletsArgsForCall)]
	fake.getUserWalletsArgsForCall = append(fake.getUserWalletsArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.GetUserWalletsStub
	fakeReturns := fake.getUserWalletsReturns
	fake.recordInvocation("GetUserWallets", []interface{}{arg1, arg2})
	fake.getUserWalletsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) GetUserWalletsCallCount() int {
	fake.getUserWalletsMutex.RLock()
	defer fake.getUserWalletsMutex.RUnlock()
	return len(fake.getUserWalletsArgsForCall)
}

func (fake *FakeAuthService) GetUserWalletsCalls(stub func(context.Context, uuid.UUID) ([]domain.UserWallet, error)) {
	fake.getUserWalletsMutex.Lock()
	defer fake.getUserWalletsMutex.Unlock()
	fake.GetUserWalletsStub = stub
}

func (fake *FakeAuthService) GetUserWalletsArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.getUserWalletsMutex.RLock()
	defer fake.getUserWalletsMutex.RUnlock()
	argsForCall := fake.getUserWalletsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) GetUserWalletsReturns(result1 []domain.UserWallet, result2 error) {
	fake.getUserWalletsMutex.Lock()
	defer fake.getUserWalletsMutex.Unlock()
	fake.GetUserWalletsStub = nil
	fake.getUserWalletsReturns = struct {
		result1 []domain.UserWallet
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) GetUserWalletsReturnsOnCall(i int, result1 []domain.UserWallet, result2 error) {
	fake.getUserWalletsMutex.Lock()
	defer fake.getUserWalletsMutex.Unlock()
	fake.GetUserWalletsStub = nil
	if fake.getUserWalletsReturnsOnCall == nil {
		fake.getUserWalletsReturnsOnCall = make(map[int]struct {
			result1 []domain.UserWallet
			result2 error
		})
	}
	fake.getUserWalletsReturnsOnCall[i] = struct {
		result1 []domain.UserWallet
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) LinkWallet(arg1 context.Context, arg2 uuid.UUID, arg3 string, arg4 string, arg5 string) error {
	fake.linkWalletMutex.Lock()
	ret, specificReturn := fake.linkWalletReturnsOnCall[len(fake.linkWalletArgsForCall)]
	fake.linkWalletArgsForCall = append(fake.linkWalletArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
		arg3 string
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.LinkWalletStub
	fakeReturns := fake.linkWalletReturns
	fake.recordInvocation("LinkWallet", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.linkWalletMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAuthService) LinkWalletCallCount() int {
	fake.linkWalletMutex.RLock()
	defer fake.linkWalletMutex.RUnlock()
	return len(fake.linkWalletArgsForCall)
}

func (fake *FakeAuthService) LinkWalletCalls(stub func(context.Context, uuid.UUID, string, string, string) error) {
	fake.linkWalletMutex.Lock()
	defer fake.linkWalletMutex.Unlock()
	fake.LinkWalletStub = stub
}

func (fake *FakeAuthService) LinkWalletArgsForCall(i int) (context.Context, uuid.UUID, string, string, string) {
	fake.linkWalletMutex.RLock()
	defer fake.linkWalletMutex.RUnlock()
	argsForCall := fake.linkWalletArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeAuthService) LinkWalletReturns(result1 error) {
	fake.linkWalletMutex.Lock()
	defer fake.linkWalletMutex.Unlock()
	fake.LinkWalletStub = nil
	fake.linkWalletReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAuthService) LinkWalletReturnsOnCall(i int, result1 error) {
	fake.linkWalletMutex.Lock()
	defer fake.linkWalletMutex.Unlock()
	fake.LinkWalletStub = nil
	if fake.linkWalletReturnsOnCall == nil {
		fake.linkWalletReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.linkWalletReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAuthService) LogSecurityEvent(arg1 context.Context, arg2 string, arg3 uuid.UUID, arg4 map[string]interface{}) error {
	fake.logSecurityEventMutex.Lock()
	ret, specificReturn := fake.logSecurityEventReturnsOnCall[len(fake.logSecurityEventArgsForCall)]
	fake.logSecurityEventArgsForCall = append(fake.logSecurityEventArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 uuid.UUID
		arg4 map[string]interface{}
	}{arg1, arg2, arg3, arg4})
	stub := fake.LogSecurityEventStub
	fakeReturns := fake.logSecurityEventReturns
	fake.recordInvocation("LogSecurityEvent", []interface{}{arg1, arg2, arg3, arg4})
	fake.logSecurityEventMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAuthService) LogSecurityEventCallCount() int {
	fake.logSecurityEventMutex.RLock()
	defer fake.logSecurityEventMutex.RUnlock()
	return len(fake.logSecurityEventArgsForCall)
}

func (fake *FakeAuthService) LogSecurityEventCalls(stub func(context.Context, string, uuid.UUID, map[string]interface{}) error) {
	fake.logSecurityEventMutex.Lock()
	defer fake.logSecurityEventMutex.Unlock()
	fake.LogSecurityEventStub = stub
}

func (fake *FakeAuthService) LogSecurityEventArgsForCall(i int) (context.Context, string, uuid.UUID, map[string]interface{}) {
	fake.logSecurityEventMutex.RLock()
	defer fake.logSecurityEventMutex.RUnlock()
	argsForCall := fake.logSecurityEventArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeAuthService) LogSecurityEventReturns(result1 error) {
	fake.logSecurityEventMutex.Lock()
	defer fake.logSecurityEventMutex.Unlock()
	fake.LogSecurityEventStub = nil
	fake.logSecurityEventReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAuthService) LogSecurityEventReturnsOnCall(i int, result1 error) {
	fake.logSecurityEventMutex.Lock()
	defer fake.logSecurityEventMutex.Unlock()
	fake.LogSecurityEventStub = nil
	if fake.logSecurityEventReturnsOnCall == nil {
		fake.logSecurityEventReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.logSecurityEventReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAuthService) Login(arg1 context.Context, arg2 string, arg3 domain.User, arg4 string) (*domain.User, error) {
	fake.loginMutex.Lock()
	ret, specificReturn := fake.loginReturnsOnCall[len(fake.loginArgsForCall)]
	fake.loginArgsForCall = append(fake.loginArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 domain.User
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.LoginStub
	fakeReturns := fake.loginReturns
	fake.recordInvocation("Login", []interface{}{arg1, arg2, arg3, arg4})
	fake.loginMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) LoginCallCount() int {
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	return len(fake.loginArgsForCall)
}

func (fake *FakeAuthService) LoginCalls(stub func(context.Context, string, domain.User, string) (*domain.User, error)) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = stub
}

func (fake *FakeAuthService) LoginArgsForCall(i int) (context.Context, string, domain.User, string) {
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	argsForCall := fake.loginArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeAuthService) LoginReturns(result1 *domain.User, result2 error) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = nil
	fake.loginReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) LoginReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = nil
	if fake.loginReturnsOnCall == nil {
		fake.loginReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.loginReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) Logout(arg1 context.Context, arg2 uuid.UUID) error {
	fake.logoutMutex.Lock()
	ret, specificReturn := fake.logoutReturnsOnCall[len(fake.logoutArgsForCall)]
	fake.logoutArgsForCall = append(fake.logoutArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.LogoutStub
	fakeReturns := fake.logoutReturns
	fake.recordInvocation("Logout", []interface{}{arg1, arg2})
	fake.logoutMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAuthService) LogoutCallCount() int {
	fake.logoutMutex.RLock()
	defer fake.logoutMutex.RUnlock()
	return len(fake.logoutArgsForCall)
}

func (fake *FakeAuthService) LogoutCalls(stub func(context.Context, uuid.UUID) error) {
	fake.logoutMutex.Lock()
	defer fake.logoutMutex.Unlock()
	fake.LogoutStub = stub
}

func (fake *FakeAuthService) LogoutArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.logoutMutex.RLock()
	defer fake.logoutMutex.RUnlock()
	argsForCall := fake.logoutArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) LogoutReturns(result1 error) {
	fake.logoutMutex.Lock()
	defer fake.logoutMutex.Unlock()
	fake.LogoutStub = nil
	fake.logoutReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAuthService) LogoutReturnsOnCall(i int, result1 error) {
	fake.logoutMutex.Lock()
	defer fake.logoutMutex.Unlock()
	fake.LogoutStub = nil
	if fake.logoutReturnsOnCall == nil {
		fake.logoutReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.logoutReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAuthService) RefreshToken(arg1 context.Context, arg2 string, arg3 string, arg4 string) (*domain.Session, string, error) {
	fake.refreshTokenMutex.Lock()
	ret, specificReturn := fake.refreshTokenReturnsOnCall[len(fake.refreshTokenArgsForCall)]
	fake.refreshTokenArgsForCall = append(fake.refreshTokenArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.RefreshTokenStub
	fakeReturns := fake.refreshTokenReturns
	fake.recordInvocation("RefreshToken", []interface{}{arg1, arg2, arg3, arg4})
	fake.refreshTokenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeAuthService) RefreshTokenCallCount() int {
	fake.refreshTokenMutex.RLock()
	defer fake.refreshTokenMutex.RUnlock()
	return len(fake.refreshTokenArgsForCall)
}

func (fake *FakeAuthService) RefreshTokenCalls(stub func(context.Context, string, string, string) (*domain.Session, string, error)) {
	fake.refreshTokenMutex.Lock()
	defer fake.refreshTokenMutex.Unlock()
	fake.RefreshTokenStub = stub
}

func (fake *FakeAuthService) RefreshTokenArgsForCall(i int) (context.Context, string, string, string) {
	fake.refreshTokenMutex.RLock()
	defer fake.refreshTokenMutex.RUnlock()
	argsForCall := fake.refreshTokenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeAuthService) RefreshTokenReturns(result1 *domain.Session, result2 string, result3 error) {
	fake.refreshTokenMutex.Lock()
	defer fake.refreshTokenMutex.Unlock()
	fake.RefreshTokenStub = nil
	fake.refreshTokenReturns = struct {
		result1 *domain.Session
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAuthService) RefreshTokenReturnsOnCall(i int, result1 *domain.Session, result2 string, result3 error) {
	fake.refreshTokenMutex.Lock()
	defer fake.refreshTokenMutex.Unlock()
	fake.RefreshTokenStub = nil
	if fake.refreshTokenReturnsOnCall == nil {
		fake.refreshTokenReturnsOnCall = make(map[int]struct {
			result1 *domain.Session
			result2 string
			result3 error
		})
	}
	fake.refreshTokenReturnsOnCall[i] = struct {
		result1 *domain.Session
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAuthService) RegisterAddressDetails(arg1 context.Context, arg2 domain.User) (*domain.User, error) {
	fake.registerAddressDetailsMutex.Lock()
	ret, specificReturn := fake.registerAddressDetailsReturnsOnCall[len(fake.registerAddressDetailsArgsForCall)]
	fake.registerAddressDetailsArgsForCall = append(fake.registerAddressDetailsArgsForCall, struct {
		arg1 context.Context
		arg2 domain.User
	}{arg1, arg2})
	stub := fake.RegisterAddressDetailsStub
	fakeReturns := fake.registerAddressDetailsReturns
	fake.recordInvocation("RegisterAddressDetails", []interface{}{arg1, arg2})
	fake.registerAddressDetailsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) RegisterAddressDetailsCallCount() int {
	fake.registerAddressDetailsMutex.RLock()
	defer fake.registerAddressDetailsMutex.RUnlock()
	return len(fake.registerAddressDetailsArgsForCall)
}

func (fake *FakeAuthService) RegisterAddressDetailsCalls(stub func(context.Context, domain.User) (*domain.User, error)) {
	fake.registerAddressDetailsMutex.Lock()
	defer fake.registerAddressDetailsMutex.Unlock()
	fake.RegisterAddressDetailsStub = stub
}

func (fake *FakeAuthService) RegisterAddressDetailsArgsForCall(i int) (context.Context, domain.User) {
	fake.registerAddressDetailsMutex.RLock()
	defer fake.registerAddressDetailsMutex.RUnlock()
	argsForCall := fake.registerAddressDetailsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) RegisterAddressDetailsReturns(result1 *domain.User, result2 error) {
	fake.registerAddressDetailsMutex.Lock()
	defer fake.registerAddressDetailsMutex.Unlock()
	fake.RegisterAddressDetailsStub = nil
	fake.registerAddressDetailsReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterAddressDetailsReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.registerAddressDetailsMutex.Lock()
	defer fake.registerAddressDetailsMutex.Unlock()
	fake.RegisterAddressDetailsStub = nil
	if fake.registerAddressDetailsReturnsOnCall == nil {
		fake.registerAddressDetailsReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.registerAddressDetailsReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterBusinessDetails(arg1 context.Context, arg2 domain.User) (*domain.User, error) {
	fake.registerBusinessDetailsMutex.Lock()
	ret, specificReturn := fake.registerBusinessDetailsReturnsOnCall[len(fake.registerBusinessDetailsArgsForCall)]
	fake.registerBusinessDetailsArgsForCall = append(fake.registerBusinessDetailsArgsForCall, struct {
		arg1 context.Context
		arg2 domain.User
	}{arg1, arg2})
	stub := fake.RegisterBusinessDetailsStub
	fakeReturns := fake.registerBusinessDetailsReturns
	fake.recordInvocation("RegisterBusinessDetails", []interface{}{arg1, arg2})
	fake.registerBusinessDetailsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) RegisterBusinessDetailsCallCount() int {
	fake.registerBusinessDetailsMutex.RLock()
	defer fake.registerBusinessDetailsMutex.RUnlock()
	return len(fake.registerBusinessDetailsArgsForCall)
}

func (fake *FakeAuthService) RegisterBusinessDetailsCalls(stub func(context.Context, domain.User) (*domain.User, error)) {
	fake.registerBusinessDetailsMutex.Lock()
	defer fake.registerBusinessDetailsMutex.Unlock()
	fake.RegisterBusinessDetailsStub = stub
}

func (fake *FakeAuthService) RegisterBusinessDetailsArgsForCall(i int) (context.Context, domain.User) {
	fake.registerBusinessDetailsMutex.RLock()
	defer fake.registerBusinessDetailsMutex.RUnlock()
	argsForCall := fake.registerBusinessDetailsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) RegisterBusinessDetailsReturns(result1 *domain.User, result2 error) {
	fake.registerBusinessDetailsMutex.Lock()
	defer fake.registerBusinessDetailsMutex.Unlock()
	fake.RegisterBusinessDetailsStub = nil
	fake.registerBusinessDetailsReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterBusinessDetailsReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.registerBusinessDetailsMutex.Lock()
	defer fake.registerBusinessDetailsMutex.Unlock()
	fake.RegisterBusinessDetailsStub = nil
	if fake.registerBusinessDetailsReturnsOnCall == nil {
		fake.registerBusinessDetailsReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.registerBusinessDetailsReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterPersonalDetails(arg1 context.Context, arg2 domain.User) (*domain.User, error) {
	fake.registerPersonalDetailsMutex.Lock()
	ret, specificReturn := fake.registerPersonalDetailsReturnsOnCall[len(fake.registerPersonalDetailsArgsForCall)]
	fake.registerPersonalDetailsArgsForCall = append(fake.registerPersonalDetailsArgsForCall, struct {
		arg1 context.Context
		arg2 domain.User
	}{arg1, arg2})
	stub := fake.RegisterPersonalDetailsStub
	fakeReturns := fake.registerPersonalDetailsReturns
	fake.recordInvocation("RegisterPersonalDetails", []interface{}{arg1, arg2})
	fake.registerPersonalDetailsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) RegisterPersonalDetailsCallCount() int {
	fake.registerPersonalDetailsMutex.RLock()
	defer fake.registerPersonalDetailsMutex.RUnlock()
	return len(fake.registerPersonalDetailsArgsForCall)
}

func (fake *FakeAuthService) RegisterPersonalDetailsCalls(stub func(context.Context, domain.User) (*domain.User, error)) {
	fake.registerPersonalDetailsMutex.Lock()
	defer fake.registerPersonalDetailsMutex.Unlock()
	fake.RegisterPersonalDetailsStub = stub
}

func (fake *FakeAuthService) RegisterPersonalDetailsArgsForCall(i int) (context.Context, domain.User) {
	fake.registerPersonalDetailsMutex.RLock()
	defer fake.registerPersonalDetailsMutex.RUnlock()
	argsForCall := fake.registerPersonalDetailsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) RegisterPersonalDetailsReturns(result1 *domain.User, result2 error) {
	fake.registerPersonalDetailsMutex.Lock()
	defer fake.registerPersonalDetailsMutex.Unlock()
	fake.RegisterPersonalDetailsStub = nil
	fake.registerPersonalDetailsReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterPersonalDetailsReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.registerPersonalDetailsMutex.Lock()
	defer fake.registerPersonalDetailsMutex.Unlock()
	fake.RegisterPersonalDetailsStub = nil
	if fake.registerPersonalDetailsReturnsOnCall == nil {
		fake.registerPersonalDetailsReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.registerPersonalDetailsReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterUser(arg1 context.Context, arg2 domain.User, arg3 string) (*domain.User, error) {
	fake.registerUserMutex.Lock()
	ret, specificReturn := fake.registerUserReturnsOnCall[len(fake.registerUserArgsForCall)]
	fake.registerUserArgsForCall = append(fake.registerUserArgsForCall, struct {
		arg1 context.Context
		arg2 domain.User
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.RegisterUserStub
	fakeReturns := fake.registerUserReturns
	fake.recordInvocation("RegisterUser", []interface{}{arg1, arg2, arg3})
	fake.registerUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) RegisterUserCallCount() int {
	fake.registerUserMutex.RLock()
	defer fake.registerUserMutex.RUnlock()
	return len(fake.registerUserArgsForCall)
}

func (fake *FakeAuthService) RegisterUserCalls(stub func(context.Context, domain.User, string) (*domain.User, error)) {
	fake.registerUserMutex.Lock()
	defer fake.registerUserMutex.Unlock()
	fake.RegisterUserStub = stub
}

func (fake *FakeAuthService) RegisterUserArgsForCall(i int) (context.Context, domain.User, string) {
	fake.registerUserMutex.RLock()
	defer fake.registerUserMutex.RUnlock()
	argsForCall := fake.registerUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAuthService) RegisterUserReturns(result1 *domain.User, result2 error) {
	fake.registerUserMutex.Lock()
	defer fake.registerUserMutex.Unlock()
	fake.RegisterUserStub = nil
	fake.registerUserReturns = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RegisterUserReturnsOnCall(i int, result1 *domain.User, result2 error) {
	fake.registerUserMutex.Lock()
	defer fake.registerUserMutex.Unlock()
	fake.RegisterUserStub = nil
	if fake.registerUserReturnsOnCall == nil {
		fake.registerUserReturnsOnCall = make(map[int]struct {
			result1 *domain.User
			result2 error
		})
	}
	fake.registerUserReturnsOnCall[i] = struct {
		result1 *domain.User
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) RevokeSession(arg1 context.Context, arg2 uuid.UUID, arg3 uuid.UUID) error {
	fake.revokeSessionMutex.Lock()
	ret, specificReturn := fake.revokeSessionReturnsOnCall[len(fake.revokeSessionArgsForCall)]
	fake.revokeSessionArgsForCall = append(fake.revokeSessionArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
		arg3 uuid.UUID
	}{arg1, arg2, arg3})
	stub := fake.RevokeSessionStub
	fakeReturns := fake.revokeSessionReturns
	fake.recordInvocation("RevokeSession", []interface{}{arg1, arg2, arg3})
	fake.revokeSessionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAuthService) RevokeSessionCallCount() int {
	fake.revokeSessionMutex.RLock()
	defer fake.revokeSessionMutex.RUnlock()
	return len(fake.revokeSessionArgsForCall)
}

func (fake *FakeAuthService) RevokeSessionCalls(stub func(context.Context, uuid.UUID, uuid.UUID) error) {
	fake.revokeSessionMutex.Lock()
	defer fake.revokeSessionMutex.Unlock()
	fake.RevokeSessionStub = stub
}

func (fake *FakeAuthService) RevokeSessionArgsForCall(i int) (context.Context, uuid.UUID, uuid.UUID) {
	fake.revokeSessionMutex.RLock()
	defer fake.revokeSessionMutex.RUnlock()
	argsForCall := fake.revokeSessionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAuthService) RevokeSessionReturns(result1 error) {
	fake.revokeSessionMutex.Lock()
	defer fake.revokeSessionMutex.Unlock()
	fake.RevokeSessionStub = nil
	fake.revokeSessionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAuthService) RevokeSessionReturnsOnCall(i int, result1 error) {
	fake.revokeSessionMutex.Lock()
	defer fake.revokeSessionMutex.Unlock()
	fake.RevokeSessionStub = nil
	if fake.revokeSessionReturnsOnCall == nil {
		fake.revokeSessionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.revokeSessionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAuthService) SetupMFA(arg1 context.Context, arg2 uuid.UUID) (string, error) {
	fake.setupMFAMutex.Lock()
	ret, specificReturn := fake.setupMFAReturnsOnCall[len(fake.setupMFAArgsForCall)]
	fake.setupMFAArgsForCall = append(fake.setupMFAArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.SetupMFAStub
	fakeReturns := fake.setupMFAReturns
	fake.recordInvocation("SetupMFA", []interface{}{arg1, arg2})
	fake.setupMFAMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) SetupMFACallCount() int {
	fake.setupMFAMutex.RLock()
	defer fake.setupMFAMutex.RUnlock()
	return len(fake.setupMFAArgsForCall)
}

func (fake *FakeAuthService) SetupMFACalls(stub func(context.Context, uuid.UUID) (string, error)) {
	fake.setupMFAMutex.Lock()
	defer fake.setupMFAMutex.Unlock()
	fake.SetupMFAStub = stub
}

func (fake *FakeAuthService) SetupMFAArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.setupMFAMutex.RLock()
	defer fake.setupMFAMutex.RUnlock()
	argsForCall := fake.setupMFAArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAuthService) SetupMFAReturns(result1 string, result2 error) {
	fake.setupMFAMutex.Lock()
	defer fake.setupMFAMutex.Unlock()
	fake.SetupMFAStub = nil
	fake.setupMFAReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) SetupMFAReturnsOnCall(i int, result1 string, result2 error) {
	fake.setupMFAMutex.Lock()
	defer fake.setupMFAMutex.Unlock()
	fake.SetupMFAStub = nil
	if fake.setupMFAReturnsOnCall == nil {
		fake.setupMFAReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.setupMFAReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) VerifyMFA(arg1 context.Context, arg2 uuid.UUID, arg3 string) (bool, error) {
	fake.verifyMFAMutex.Lock()
	ret, specificReturn := fake.verifyMFAReturnsOnCall[len(fake.verifyMFAArgsForCall)]
	fake.verifyMFAArgsForCall = append(fake.verifyMFAArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.VerifyMFAStub
	fakeReturns := fake.verifyMFAReturns
	fake.recordInvocation("VerifyMFA", []interface{}{arg1, arg2, arg3})
	fake.verifyMFAMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAuthService) VerifyMFACallCount() int {
	fake.verifyMFAMutex.RLock()
	defer fake.verifyMFAMutex.RUnlock()
	return len(fake.verifyMFAArgsForCall)
}

func (fake *FakeAuthService) VerifyMFACalls(stub func(context.Context, uuid.UUID, string) (bool, error)) {
	fake.verifyMFAMutex.Lock()
	defer fake.verifyMFAMutex.Unlock()
	fake.VerifyMFAStub = stub
}

func (fake *FakeAuthService) VerifyMFAArgsForCall(i int) (context.Context, uuid.UUID, string) {
	fake.verifyMFAMutex.RLock()
	defer fake.verifyMFAMutex.RUnlock()
	argsForCall := fake.verifyMFAArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAuthService) VerifyMFAReturns(result1 bool, result2 error) {
	fake.verifyMFAMutex.Lock()
	defer fake.verifyMFAMutex.Unlock()
	fake.VerifyMFAStub = nil
	fake.verifyMFAReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) VerifyMFAReturnsOnCall(i int, result1 bool, result2 error) {
	fake.verifyMFAMutex.Lock()
	defer fake.verifyMFAMutex.Unlock()
	fake.VerifyMFAStub = nil
	if fake.verifyMFAReturnsOnCall == nil {
		fake.verifyMFAReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.verifyMFAReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeAuthService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.authenticateWithWeb3Mutex.RLock()
	defer fake.authenticateWithWeb3Mutex.RUnlock()
	fake.checkEmailExistsMutex.RLock()
	defer fake.checkEmailExistsMutex.RUnlock()
	fake.createSessionMutex.RLock()
	defer fake.createSessionMutex.RUnlock()
	fake.getActiveDevicesMutex.RLock()
	defer fake.getActiveDevicesMutex.RUnlock()
	fake.getProfileCompletionStatusMutex.RLock()
	defer fake.getProfileCompletionStatusMutex.RUnlock()
	fake.getUserByEmailMutex.RLock()
	defer fake.getUserByEmailMutex.RUnlock()
	fake.getUserByIDMutex.RLock()
	defer fake.getUserByIDMutex.RUnlock()
	fake.getUserWalletsMutex.RLock()
	defer fake.getUserWalletsMutex.RUnlock()
	fake.linkWalletMutex.RLock()
	defer fake.linkWalletMutex.RUnlock()
	fake.logSecurityEventMutex.RLock()
	defer fake.logSecurityEventMutex.RUnlock()
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	fake.logoutMutex.RLock()
	defer fake.logoutMutex.RUnlock()
	fake.refreshTokenMutex.RLock()
	defer fake.refreshTokenMutex.RUnlock()
	fake.registerAddressDetailsMutex.RLock()
	defer fake.registerAddressDetailsMutex.RUnlock()
	fake.registerBusinessDetailsMutex.RLock()
	defer fake.registerBusinessDetailsMutex.RUnlock()
	fake.registerPersonalDetailsMutex.RLock()
	defer fake.registerPersonalDetailsMutex.RUnlock()
	fake.registerUserMutex.RLock()
	defer fake.registerUserMutex.RUnlock()
	fake.revokeSessionMutex.RLock()
	defer fake.revokeSessionMutex.RUnlock()
	fake.setupMFAMutex.RLock()
	defer fake.setupMFAMutex.RUnlock()
	fake.verifyMFAMutex.RLock()
	defer fake.verifyMFAMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAuthService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ports.AuthService = new(FakeAuthService)
