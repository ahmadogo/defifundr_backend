// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sessions.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const blockAllUserSessions = `-- name: BlockAllUserSessions :exec
UPDATE sessions
SET is_blocked = true
WHERE user_id = $1
`

// Blocks all sessions for a specific user
func (q *Queries) BlockAllUserSessions(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, blockAllUserSessions, userID)
	return err
}

const blockExpiredSessions = `-- name: BlockExpiredSessions :exec
UPDATE sessions
SET is_blocked = true
WHERE expires_at <= now() AND is_blocked = false
`

// Blocks all expired sessions
func (q *Queries) BlockExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, blockExpiredSessions)
	return err
}

const blockSession = `-- name: BlockSession :exec
UPDATE sessions
SET is_blocked = true
WHERE id = $1
`

// Blocks a session (marks it as invalid)
func (q *Queries) BlockSession(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, blockSession, id)
	return err
}

const countActiveSessions = `-- name: CountActiveSessions :one
SELECT COUNT(*) FROM sessions
WHERE is_blocked = false AND expires_at > now()
`

// Counts the number of active sessions
func (q *Queries) CountActiveSessions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveSessions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countActiveSessionsByUserID = `-- name: CountActiveSessionsByUserID :one
SELECT COUNT(*) FROM sessions
WHERE user_id = $1 AND is_blocked = false AND expires_at > now()
`

// Counts the number of active sessions for a specific user
func (q *Queries) CountActiveSessionsByUserID(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveSessionsByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
  id,
  user_id,
  refresh_token,
  user_agent,
  web_oauth_client_id,
  oauth_access_token,
  oauth_id_token,
  user_login_type,
  last_used_at,
  mfa_enabled,
  client_ip,
  is_blocked,
  expires_at,
  created_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, COALESCE($14, now())
) RETURNING id, user_id, refresh_token, user_agent, last_used_at, web_oauth_client_id, oauth_access_token, oauth_id_token, user_login_type, mfa_enabled, client_ip, is_blocked, expires_at, created_at
`

type CreateSessionParams struct {
	ID               uuid.UUID        `json:"id"`
	UserID           uuid.UUID        `json:"user_id"`
	RefreshToken     string           `json:"refresh_token"`
	UserAgent        string           `json:"user_agent"`
	WebOauthClientID pgtype.Text      `json:"web_oauth_client_id"`
	OauthAccessToken pgtype.Text      `json:"oauth_access_token"`
	OauthIDToken     pgtype.Text      `json:"oauth_id_token"`
	UserLoginType    string           `json:"user_login_type"`
	LastUsedAt       pgtype.Timestamp `json:"last_used_at"`
	MfaEnabled       bool             `json:"mfa_enabled"`
	ClientIp         string           `json:"client_ip"`
	IsBlocked        bool             `json:"is_blocked"`
	ExpiresAt        pgtype.Timestamp `json:"expires_at"`
	Column14         interface{}      `json:"column_14"`
}

// Creates a new session and returns the created session record
func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Sessions, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.ID,
		arg.UserID,
		arg.RefreshToken,
		arg.UserAgent,
		arg.WebOauthClientID,
		arg.OauthAccessToken,
		arg.OauthIDToken,
		arg.UserLoginType,
		arg.LastUsedAt,
		arg.MfaEnabled,
		arg.ClientIp,
		arg.IsBlocked,
		arg.ExpiresAt,
		arg.Column14,
	)
	var i Sessions
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshToken,
		&i.UserAgent,
		&i.LastUsedAt,
		&i.WebOauthClientID,
		&i.OauthAccessToken,
		&i.OauthIDToken,
		&i.UserLoginType,
		&i.MfaEnabled,
		&i.ClientIp,
		&i.IsBlocked,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM sessions
WHERE expires_at < $1
`

// Cleans up expired sessions that are older than the specified date
func (q *Queries) DeleteExpiredSessions(ctx context.Context, expiresAt pgtype.Timestamp) error {
	_, err := q.db.Exec(ctx, deleteExpiredSessions, expiresAt)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions
WHERE id = $1
`

// Deletes a session by its ID
func (q *Queries) DeleteSession(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSession, id)
	return err
}

const deleteSessionsByUserID = `-- name: DeleteSessionsByUserID :exec
DELETE FROM sessions
WHERE user_id = $1
`

// Deletes all sessions for a specific user
func (q *Queries) DeleteSessionsByUserID(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSessionsByUserID, userID)
	return err
}

const getActiveSessions = `-- name: GetActiveSessions :many
SELECT id, user_id, refresh_token, user_agent, last_used_at, web_oauth_client_id, oauth_access_token, oauth_id_token, user_login_type, mfa_enabled, client_ip, is_blocked, expires_at, created_at FROM sessions
WHERE is_blocked = false AND expires_at > now()
ORDER BY created_at DESC
LIMIT $1
OFFSET $2
`

type GetActiveSessionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Retrieves active (non-expired, non-blocked) sessions with pagination
func (q *Queries) GetActiveSessions(ctx context.Context, arg GetActiveSessionsParams) ([]Sessions, error) {
	rows, err := q.db.Query(ctx, getActiveSessions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Sessions{}
	for rows.Next() {
		var i Sessions
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RefreshToken,
			&i.UserAgent,
			&i.LastUsedAt,
			&i.WebOauthClientID,
			&i.OauthAccessToken,
			&i.OauthIDToken,
			&i.UserLoginType,
			&i.MfaEnabled,
			&i.ClientIp,
			&i.IsBlocked,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveSessionsByUserID = `-- name: GetActiveSessionsByUserID :many
SELECT id, user_id, refresh_token, user_agent, last_used_at, web_oauth_client_id, oauth_access_token, oauth_id_token, user_login_type, mfa_enabled, client_ip, is_blocked, expires_at, created_at FROM sessions
WHERE user_id = $1 AND is_blocked = false AND expires_at > now()
ORDER BY created_at DESC
`

// Retrieves active sessions for a specific user
func (q *Queries) GetActiveSessionsByUserID(ctx context.Context, userID uuid.UUID) ([]Sessions, error) {
	rows, err := q.db.Query(ctx, getActiveSessionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Sessions{}
	for rows.Next() {
		var i Sessions
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RefreshToken,
			&i.UserAgent,
			&i.LastUsedAt,
			&i.WebOauthClientID,
			&i.OauthAccessToken,
			&i.OauthIDToken,
			&i.UserLoginType,
			&i.MfaEnabled,
			&i.ClientIp,
			&i.IsBlocked,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, user_id, refresh_token, user_agent, last_used_at, web_oauth_client_id, oauth_access_token, oauth_id_token, user_login_type, mfa_enabled, client_ip, is_blocked, expires_at, created_at FROM sessions
WHERE id = $1
LIMIT 1
`

// Retrieves a session by its ID
func (q *Queries) GetSessionByID(ctx context.Context, id uuid.UUID) (Sessions, error) {
	row := q.db.QueryRow(ctx, getSessionByID, id)
	var i Sessions
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshToken,
		&i.UserAgent,
		&i.LastUsedAt,
		&i.WebOauthClientID,
		&i.OauthAccessToken,
		&i.OauthIDToken,
		&i.UserLoginType,
		&i.MfaEnabled,
		&i.ClientIp,
		&i.IsBlocked,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionByRefreshToken = `-- name: GetSessionByRefreshToken :one
SELECT id, user_id, refresh_token, user_agent, last_used_at, web_oauth_client_id, oauth_access_token, oauth_id_token, user_login_type, mfa_enabled, client_ip, is_blocked, expires_at, created_at FROM sessions
WHERE refresh_token = $1
LIMIT 1
`

// Retrieves a session by refresh token
func (q *Queries) GetSessionByRefreshToken(ctx context.Context, refreshToken string) (Sessions, error) {
	row := q.db.QueryRow(ctx, getSessionByRefreshToken, refreshToken)
	var i Sessions
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshToken,
		&i.UserAgent,
		&i.LastUsedAt,
		&i.WebOauthClientID,
		&i.OauthAccessToken,
		&i.OauthIDToken,
		&i.UserLoginType,
		&i.MfaEnabled,
		&i.ClientIp,
		&i.IsBlocked,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionsByUserID = `-- name: GetSessionsByUserID :many
SELECT id, user_id, refresh_token, user_agent, last_used_at, web_oauth_client_id, oauth_access_token, oauth_id_token, user_login_type, mfa_enabled, client_ip, is_blocked, expires_at, created_at FROM sessions
WHERE user_id = $1
ORDER BY created_at DESC
`

// Retrieves all sessions for a specific user
func (q *Queries) GetSessionsByUserID(ctx context.Context, userID uuid.UUID) ([]Sessions, error) {
	rows, err := q.db.Query(ctx, getSessionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Sessions{}
	for rows.Next() {
		var i Sessions
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RefreshToken,
			&i.UserAgent,
			&i.LastUsedAt,
			&i.WebOauthClientID,
			&i.OauthAccessToken,
			&i.OauthIDToken,
			&i.UserLoginType,
			&i.MfaEnabled,
			&i.ClientIp,
			&i.IsBlocked,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRefreshToken = `-- name: UpdateRefreshToken :one
UPDATE sessions
SET refresh_token = $2
WHERE id = $1
RETURNING id, user_id, refresh_token, user_agent, last_used_at, web_oauth_client_id, oauth_access_token, oauth_id_token, user_login_type, mfa_enabled, client_ip, is_blocked, expires_at, created_at
`

type UpdateRefreshTokenParams struct {
	ID           uuid.UUID `json:"id"`
	RefreshToken string    `json:"refresh_token"`
}

// Updates just the refresh token of a session
func (q *Queries) UpdateRefreshToken(ctx context.Context, arg UpdateRefreshTokenParams) (Sessions, error) {
	row := q.db.QueryRow(ctx, updateRefreshToken, arg.ID, arg.RefreshToken)
	var i Sessions
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshToken,
		&i.UserAgent,
		&i.LastUsedAt,
		&i.WebOauthClientID,
		&i.OauthAccessToken,
		&i.OauthIDToken,
		&i.UserLoginType,
		&i.MfaEnabled,
		&i.ClientIp,
		&i.IsBlocked,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateSession = `-- name: UpdateSession :one
UPDATE sessions
SET
  user_agent = COALESCE($2, user_agent),
  web_oauth_client_id = $3,
  oauth_access_token = $4,
  oauth_id_token = $5,
  mfa_enabled = COALESCE($6, mfa_enabled),
  client_ip = COALESCE($7, client_ip),
  is_blocked = COALESCE($8, is_blocked),
  expires_at = COALESCE($9, expires_at),
  last_used_at = COALESCE($10, last_used_at)
WHERE id = $1
RETURNING id, user_id, refresh_token, user_agent, last_used_at, web_oauth_client_id, oauth_access_token, oauth_id_token, user_login_type, mfa_enabled, client_ip, is_blocked, expires_at, created_at
`

type UpdateSessionParams struct {
	ID               uuid.UUID        `json:"id"`
	UserAgent        string           `json:"user_agent"`
	WebOauthClientID pgtype.Text      `json:"web_oauth_client_id"`
	OauthAccessToken pgtype.Text      `json:"oauth_access_token"`
	OauthIDToken     pgtype.Text      `json:"oauth_id_token"`
	MfaEnabled       bool             `json:"mfa_enabled"`
	ClientIp         string           `json:"client_ip"`
	IsBlocked        bool             `json:"is_blocked"`
	ExpiresAt        pgtype.Timestamp `json:"expires_at"`
	LastUsedAt       pgtype.Timestamp `json:"last_used_at"`
}

// Updates session details
func (q *Queries) UpdateSession(ctx context.Context, arg UpdateSessionParams) (Sessions, error) {
	row := q.db.QueryRow(ctx, updateSession,
		arg.ID,
		arg.UserAgent,
		arg.WebOauthClientID,
		arg.OauthAccessToken,
		arg.OauthIDToken,
		arg.MfaEnabled,
		arg.ClientIp,
		arg.IsBlocked,
		arg.ExpiresAt,
		arg.LastUsedAt,
	)
	var i Sessions
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshToken,
		&i.UserAgent,
		&i.LastUsedAt,
		&i.WebOauthClientID,
		&i.OauthAccessToken,
		&i.OauthIDToken,
		&i.UserLoginType,
		&i.MfaEnabled,
		&i.ClientIp,
		&i.IsBlocked,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateSessionRefreshToken = `-- name: UpdateSessionRefreshToken :one
UPDATE sessions
SET 
  refresh_token = $2,
  last_used_at = $3
WHERE id = $1
RETURNING id, user_id, refresh_token, user_agent, last_used_at, web_oauth_client_id, oauth_access_token, oauth_id_token, user_login_type, mfa_enabled, client_ip, is_blocked, expires_at, created_at
`

type UpdateSessionRefreshTokenParams struct {
	ID           uuid.UUID        `json:"id"`
	RefreshToken string           `json:"refresh_token"`
	LastUsedAt   pgtype.Timestamp `json:"last_used_at"`
}

func (q *Queries) UpdateSessionRefreshToken(ctx context.Context, arg UpdateSessionRefreshTokenParams) (Sessions, error) {
	row := q.db.QueryRow(ctx, updateSessionRefreshToken, arg.ID, arg.RefreshToken, arg.LastUsedAt)
	var i Sessions
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshToken,
		&i.UserAgent,
		&i.LastUsedAt,
		&i.WebOauthClientID,
		&i.OauthAccessToken,
		&i.OauthIDToken,
		&i.UserLoginType,
		&i.MfaEnabled,
		&i.ClientIp,
		&i.IsBlocked,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}
