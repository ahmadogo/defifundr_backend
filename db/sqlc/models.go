// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package sqlc

import (
	"database/sql/driver"
	"fmt"
	"net/netip"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type OtpPurpose string

const (
	OtpPurposeEmailVerification OtpPurpose = "email_verification"
	OtpPurposePasswordReset     OtpPurpose = "password_reset"
	OtpPurposePhoneVerification OtpPurpose = "phone_verification"
	OtpPurposeAccountRecovery   OtpPurpose = "account_recovery"
	OtpPurposeTwoFactorAuth     OtpPurpose = "two_factor_auth"
	OtpPurposeLoginConfirmation OtpPurpose = "login_confirmation"
)

func (e *OtpPurpose) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OtpPurpose(s)
	case string:
		*e = OtpPurpose(s)
	default:
		return fmt.Errorf("unsupported scan type for OtpPurpose: %T", src)
	}
	return nil
}

type NullOtpPurpose struct {
	OtpPurpose OtpPurpose `json:"otp_purpose"`
	Valid      bool       `json:"valid"` // Valid is true if OtpPurpose is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOtpPurpose) Scan(value interface{}) error {
	if value == nil {
		ns.OtpPurpose, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OtpPurpose.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOtpPurpose) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OtpPurpose), nil
}

type Kyc struct {
	ID                   uuid.UUID `json:"id"`
	UserID               uuid.UUID `json:"user_id"`
	FaceVerification     bool      `json:"face_verification"`
	IdentityVerification bool      `json:"identity_verification"`
	VerificationType     string    `json:"verification_type"`
	VerificationNumber   string    `json:"verification_number"`
	VerificationStatus   string    `json:"verification_status"`
	UpdatedAt            time.Time `json:"updated_at"`
	CreatedAt            time.Time `json:"created_at"`
}

type OtpVerifications struct {
	ID            uuid.UUID          `json:"id"`
	UserID        pgtype.UUID        `json:"user_id"`
	OtpCode       string             `json:"otp_code"`
	HashedOtp     string             `json:"hashed_otp"`
	Purpose       OtpPurpose         `json:"purpose"`
	ContactMethod pgtype.Text        `json:"contact_method"`
	AttemptsMade  int32              `json:"attempts_made"`
	MaxAttempts   int32              `json:"max_attempts"`
	IsVerified    bool               `json:"is_verified"`
	CreatedAt     time.Time          `json:"created_at"`
	ExpiresAt     time.Time          `json:"expires_at"`
	VerifiedAt    pgtype.Timestamptz `json:"verified_at"`
	IpAddress     *netip.Addr        `json:"ip_address"`
	UserAgent     pgtype.Text        `json:"user_agent"`
	DeviceID      pgtype.UUID        `json:"device_id"`
}

type SecurityEvents struct {
	ID        uuid.UUID        `json:"id"`
	UserID    uuid.UUID        `json:"user_id"`
	EventType string           `json:"event_type"`
	IpAddress string           `json:"ip_address"`
	UserAgent pgtype.Text      `json:"user_agent"`
	Metadata  []byte           `json:"metadata"`
	Timestamp pgtype.Timestamp `json:"timestamp"`
}

type Sessions struct {
	ID               uuid.UUID        `json:"id"`
	UserID           uuid.UUID        `json:"user_id"`
	RefreshToken     string           `json:"refresh_token"`
	UserAgent        string           `json:"user_agent"`
	LastUsedAt       pgtype.Timestamp `json:"last_used_at"`
	WebOauthClientID pgtype.Text      `json:"web_oauth_client_id"`
	OauthAccessToken pgtype.Text      `json:"oauth_access_token"`
	OauthIDToken     pgtype.Text      `json:"oauth_id_token"`
	UserLoginType    string           `json:"user_login_type"`
	MfaEnabled       bool             `json:"mfa_enabled"`
	ClientIp         string           `json:"client_ip"`
	IsBlocked        bool             `json:"is_blocked"`
	ExpiresAt        pgtype.Timestamp `json:"expires_at"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
}

type Transactions struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
	TxHash string    `json:"tx_hash"`
	// hashed transaction pin
	TransactionPinHash string `json:"transaction_pin_hash"`
	// created, pending, not_found, failed
	Status    string    `json:"status"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

type UserDeviceTokens struct {
	ID                    uuid.UUID          `json:"id"`
	UserID                uuid.UUID          `json:"user_id"`
	DeviceToken           string             `json:"device_token"`
	Platform              string             `json:"platform"`
	DeviceType            pgtype.Text        `json:"device_type"`
	DeviceModel           pgtype.Text        `json:"device_model"`
	OsName                pgtype.Text        `json:"os_name"`
	OsVersion             pgtype.Text        `json:"os_version"`
	PushNotificationToken pgtype.Text        `json:"push_notification_token"`
	IsActive              bool               `json:"is_active"`
	IsVerified            bool               `json:"is_verified"`
	LastUsedAt            pgtype.Timestamptz `json:"last_used_at"`
	FirstRegisteredAt     time.Time          `json:"first_registered_at"`
	AppVersion            pgtype.Text        `json:"app_version"`
	ClientIp              pgtype.Text        `json:"client_ip"`
	ExpiresAt             pgtype.Timestamptz `json:"expires_at"`
	IsRevoked             bool               `json:"is_revoked"`
}

type UserWallets struct {
	ID        uuid.UUID        `json:"id"`
	UserID    uuid.UUID        `json:"user_id"`
	Address   string           `json:"address"`
	Type      string           `json:"type"`
	Chain     string           `json:"chain"`
	IsDefault bool             `json:"is_default"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

type Users struct {
	ID             uuid.UUID   `json:"id"`
	Email          string      `json:"email"`
	PasswordHash   pgtype.Text `json:"password_hash"`
	ProfilePicture pgtype.Text `json:"profile_picture"`
	// business, personal
	AccountType string      `json:"account_type"`
	Gender      pgtype.Text `json:"gender"`
	// contractor, freelancer, employee
	PersonalAccountType   string             `json:"personal_account_type"`
	PhoneNumber           pgtype.Text        `json:"phone_number"`
	PhoneNumberVerified   pgtype.Bool        `json:"phone_number_verified"`
	PhoneNumberVerifiedAt pgtype.Timestamptz `json:"phone_number_verified_at"`
	FirstName             string             `json:"first_name"`
	LastName              string             `json:"last_name"`
	Nationality           string             `json:"nationality"`
	ResidentialCountry    pgtype.Text        `json:"residential_country"`
	JobRole               pgtype.Text        `json:"job_role"`
	CompanyName           pgtype.Text        `json:"company_name"`
	CompanyAddress        pgtype.Text        `json:"company_address"`
	CompanyCity           pgtype.Text        `json:"company_city"`
	CompanyPostalCode     pgtype.Text        `json:"company_postal_code"`
	CompanyCountry        pgtype.Text        `json:"company_country"`
	UserAddress           pgtype.Text        `json:"user_address"`
	UserCity              pgtype.Text        `json:"user_city"`
	UserPostalCode        pgtype.Text        `json:"user_postal_code"`
	EmployeeType          pgtype.Text        `json:"employee_type"`
	AuthProvider          pgtype.Text        `json:"auth_provider"`
	ProviderID            string             `json:"provider_id"`
	CompanyWebsite        pgtype.Text        `json:"company_website"`
	EmploymentType        pgtype.Text        `json:"employment_type"`
	CreatedAt             time.Time          `json:"created_at"`
	UpdatedAt             time.Time          `json:"updated_at"`
}

type Waitlist struct {
	ID             uuid.UUID          `json:"id"`
	Email          string             `json:"email"`
	FullName       pgtype.Text        `json:"full_name"`
	ReferralCode   string             `json:"referral_code"`
	ReferralSource pgtype.Text        `json:"referral_source"`
	Status         string             `json:"status"`
	SignupDate     time.Time          `json:"signup_date"`
	InvitedDate    pgtype.Timestamptz `json:"invited_date"`
	RegisteredDate pgtype.Timestamptz `json:"registered_date"`
	Metadata       []byte             `json:"metadata"`
	CreatedAt      time.Time          `json:"created_at"`
	UpdatedAt      time.Time          `json:"updated_at"`
}
